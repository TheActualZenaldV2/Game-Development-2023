










<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>3D First Person Shooter</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
        z-index: -1;
      }
    
      #ammo {
        z-index: 99;
        position: fixed;
        bottom: 80px;
        left: 50px;
        color: white;
        font-weight: bolder;
      }
      #ammoCount {
        font-size: 25px
      }
      #hitDisplay, #youHitDisplay, #killDisplay, #youDiedDisplay, #youKilledDisplay, #newRound {
  z-index: 9099999;
  position: fixed;
  color: white;
  font-weight: bolder;
  font-size: 50px;
}

#hitDisplay {
  top: 100px;
  left: 100px;
}

#youHitDisplay {
  top: 150px;
  left: 200px;
}

#killDisplay {
  top: 200px;
  left: 300px;
}

#youDiedDisplay {
  top: 50%; /* Center vertically */
  left: 50%; /* Center horizontally */
  transform: translate(-50%, -50%); /* Center both vertically and horizontally */
}

#youKilledDisplay {
  top: 70%; /* Adjust as needed */
  left: 40%; /* Adjust as needed */
}

#newRound {
  top: 80%; /* Adjust as needed */
  left: 60%; /* Adjust as needed */
}


      /* Animation for hit */
    .hit-animation {
      animation-name: hitAnimation;
      animation-duration: 1s;
      animation-timing-function: ease;
    }
    @keyframes hitAnimation {
      0%, 100% {
        color: white;
      }
      50% {
        color: red; /* Change to the desired hit color */
      }
    }
    /* Animation for kill */
    .kill-animation {
      animation-name: killAnimation;
      animation-duration: 1s;
      animation-timing-function: ease;
    }
    @keyframes killAnimation {
      0%, 100% {
        color: white;
      }
      50% {
        color: green; /* Change to the desired kill color */
      }
    }
    /* Animation for "You died" */
    .you-died-animation {
      animation-name: youDiedAnimation;
      animation-duration: 2s;
      animation-timing-function: ease;
    }
    @keyframes youDiedAnimation {
      0% {
        opacity: 0;
      }
      50% {
        opacity: 1;
      }
      100% {
        opacity: 0;
      }
    }

    /* Animation for "You Killed" */
.you-killed-animation {
  animation-name: youKilledAnimation;
  animation-duration: 1s;
  animation-timing-function: ease;
}
@keyframes youKilledAnimation {
  0%, 100% {
    color: white;
  }
  50% {
    color: green; /* Change to the desired color */
  }
}

/* Animation for "You Hit" */
.you-hit-animation {
  animation-name: youHitAnimation;
  animation-duration: 1s;
  animation-timing-function: ease;
}
@keyframes youHitAnimation {
  0%, 100% {
    color: white;
  }
  50% {
    color: red; /* Change to the desired color */
  }
}

    #crosshair {
	z-index: 1;
	width: 20px;
	height: 20px;
	position: absolute;
	top: calc(50% - 10px);
	left: calc(50% - 10px);
}
#crosshair::before,#crosshair::after {
	content: "";
	position: absolute;
	width: 10px;
	height: 2px;
	background-color: #ffffff;
	top: calc(50% - 1px);
	left: calc(50% - 5px);
}
#crosshair::after {
	transform: rotate(90deg);
}

#loading-text {
	color: white;
	display: none;
	font-size: large;
	font-weight: bold;
	/*position middle of screen*/
	position: absolute;
	top: 45%;
	left: 50%;
	transform: translate(-50%, -50%);
	font-size: 20px;
	z-index: 10000;
}

#gameOverlay {
  position: absolute;
  z-index: 999;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background-color: black;
  transition: 0.5s opacity;
}


.cool-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: #33333345;
    color: white;
    padding: 10px;
    z-index: 99;
    text-align: center;
    display: none;
}

.cool-bar i {
    margin-right: 8px;
}

.progress-bar {
    background-color: #555;
    height: 10px;
    border-radius: 5px;
    margin-top: 5px;
}

.progress {
    width: 0;
    height: 100%;
    background-color: red;
    border-radius: 5px;
}
#pingContainer {
    position: fixed;
    top: 50px;
    left: 5px; /* Adjust the right distance from the edge of the viewport */
    background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black background */
    padding: 10px;
    max-width: 200px;
    border-radius: 5px;
    color: white;
  }
  #pingContainer #pingTime {
    font-weight: bold;
  }
  
#enemyContainer {
    position: fixed;
    top: 50px;
    right: 5px; /* Adjust the right distance from the edge of the viewport */
    background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black background */
    padding: 10px;
    max-width: 200px;
    border-radius: 5px;
    color: white;
  }


  body {
        background-color: #000;
        color: #fff;
    }

    #menu {
      color: white;
      background: linear-gradient(45deg, rgba(4, 4, 4, 0.8), rgba(26, 35, 38, 0.8));

        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        align-items: center;
        flex-direction: column;
        justify-content: space-around;
        text-shadow: 5px #000000;
        border-radius: 5%;
        width: 25%;
        height: 35%;
   
    }

    #menu-button {
        text-align: center;
        cursor: pointer;
    }
    

    #menu-content {
        text-align: center;
        width: 300px;
        padding: 20px;
        border: 2px solid #fff;
        border-radius: 15px;
        background-color: rgba(0, 0, 0, 0.7);
        display: none;
    }



    #animation {
        z-index: -1;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
    /* CSS for fade animations */
.fade-in {
    opacity: 1;
    visibility: visible;
    transition: opacity 0.5s ease-in;
    animation: rotate-in-2-cw 0.5s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;
}

.fade-out {
    opacity: 0;
    transition: opacity 0.5s ease-out;
    animation: rotate-out-2-cw 0.6s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;
}
@keyframes rotate-in-2-cw {
  0% {
    -webkit-transform: rotate(-45deg);
            transform: rotate(-45deg);
    opacity: 0;
  }
  100% {
    -webkit-transform: rotate(0);
            transform: rotate(0);
    opacity: 1;
  }
}
@keyframes rotate-out-2-cw {
  0% {
    -webkit-transform: rotate(0);
            transform: rotate(0);
    opacity: 1;
  }
  100% {
    -webkit-transform: rotate(45deg);
            transform: rotate(45deg);
    opacity: 0;
  }
}
    </style>
  </head>
  <body>

    <div id="menu" class="text-center">
      <h1>Voxel 1v1</h1>

  <div class="container" id="main">
      <div class="row">
          <div class="col-md-6" style="border-right: 2px solid white">
              <button id="settings-button" class="btn btn-primary"><i class="fas fa-cog"></i> Settings</button> <br> <br>
              <button id="play-button" class="btn btn-primary"><i class="fa-solid fa-play"></i> Play</button> <br> <br>
          </div>
          <div class="col-md-6" id="main2" style="border-left: 2px solid white">
              <div id="settings-menu" class="fade-out">
                  <div class="text-left">
                      <h1 class="section-title">Settings</h1>
                      <!-- Your settings menu content here -->
                  </div>
              </div>
          
              <div id="play-menu" class="fade-out">
                  <div class="text-left">
                      <h1 class="section-title">Play</h1>
                      <!-- Your play menu content here -->
                  </div>
              </div>
          
             
          </div>
      </div>
  </div> 


</div>

  <div id="animation"></div> <!-- Placeholder for Three.js animation -->



    <span id="loading-text"><i class="fa-solid fa-gear fa-spin"></i> Please Wait....</span>
<div id="gameContainer" style="display: none;">
    <div id="statsContainer"></div>
<div id="pingContainer">
     <div id="health"> Health: <span id="healthNumber">100</span></div>
     <div id="kills"> Kills: <span id="killsCount">0</span></div>
     <div id="death"> Deaths: <span id="deathCount">0</span></div>
     <div id="ammo"> Ammo: <span id="ammoCount"> 0</span></div>
     <p style="color: white;"><i class="fa-solid fa-signal fa-bounce"></i> Ping: <span id="pingTime">-</span> ms</p> 
     </div>

     <div id="enemyContainer">
      <div id="enemyHealth"> Enemy Health: <span id="enemyHealthNumber">-</span></div>
      </div>
     
  <div id="hitDisplay" style="display: none;" class="hit-animation">You Got Hit!</div>
  <div id="youDiedDisplay" style="display: none;"  class="you-died-animation">You Died</div>
  <div id="youKilledDisplay" style="display: none;"  class="you-killed-animation">Kill!</div>
  <div id="youHitDisplay" style="display: none;"  class="you-hit-animation">Hit! </div>
  <div id="gameOverlay" style="opacity: 0;">
  <div id="newRound"> New Round Starting...</div>
</div>


  <div id="crosshair"></div>

  <div class="cool-bar" id="dash-progress-bar">
    <i class="fas fa-running"></i> Dashing
    <div class="progress-bar">
        <div class="progress"></div>
    </div>
</div>
</div>

<div id="gameOverContainer" style="display: none;">
  
<div class="container mt-5">
  <h2>Game Leaderboard</h2>
  <table class="table">
    <thead>
      <tr>
        <th>Player ID</th>
        <th>Kills</th>
        <th>Deaths</th>
        <th>K/D Ratio</th>
      </tr>
    </thead>
    <tbody id="leaderboardBody">
      <!-- Player data will be dynamically inserted here -->
    </tbody>
    <button onclick="{location.reload()}">Restart</button>
  </table>
</div>
</div>


    <script src="https://www.gstatic.com/firebasejs/7.17.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/7.17.1/firebase-database.js"></script>
  <script src="https://www.gstatic.com/firebasejs/7.14.5/firebase-auth.js"></script>
  <script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.1.9/p5.min.js"> </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.topology.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@0.5.24/dist/vanta.fog.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.rings.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.waves.min.js"></script>
 
  <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.135.0/build/three.module.js",
            "three/addons/objects/Lensflare.js": "https://unpkg.com/three@0.135.0/examples/jsm/objects/Lensflare.js",
            "three/addons/controls/PointerLockControls.js": "https://unpkg.com/three@0.135.0/examples/jsm/controls/PointerLockControls.js"
        }
    }
  </script>
  <script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.118/build/three.module.js';
    import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';
    import { Reflector } from 'https://cdn.jsdelivr.net/npm/three@0.135/examples/jsm/objects/Reflector.js';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { FBXLoader } from 'https://unpkg.com/three@0.118.0/examples/jsm/loaders/FBXLoader.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.118/examples/jsm/loaders/GLTFLoader.js';
    


    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);

      

    const textureLoader = new THREE.TextureLoader();
    const textureFlare0 = textureLoader.load('https://i.imgur.com/80OABdD.png');
    const textureFlare3 = textureLoader.load('https://i.imgur.com/26zm7OM.png');
  
    function addLight(h, s, l, x, y, z) {
      console.log(x, y, z);
      const light = new THREE.PointLight(0xffffff, 1, 2000, 0);
      
    // Enable shadow casting for the light
    light.castShadow = true;

// Configure shadow properties for the light
light.shadow.mapSize.width = 1024;
light.shadow.mapSize.height = 1024;
      light.color.setHSL(h, s, l);
      light.position.set(x, y, z);
      scene.add(light);
  
      const lensflare = new Lensflare();
      lensflare.addElement(new LensflareElement(textureFlare0, 700, 0, light.color));
      lensflare.addElement(new LensflareElement(textureFlare3, 60, 0.6));
      lensflare.addElement(new LensflareElement(textureFlare3, 70, 0.7));
      lensflare.addElement(new LensflareElement(textureFlare3, 120, 0.9));
      lensflare.addElement(new LensflareElement(textureFlare3, 70, 1));
      light.add(lensflare);
    }
  

    // Lights {x: 2.668993, y: -0.5, z: 6.648875}
    addLight(0.08, 0.8, 0.5, -100, 150, 100);   // Adjust the z position to bring it closer

    let length = 25; // Adjust this value to change the length of the rectangle
let height = 2.5; // Adjust this value to change the height of the rectangle

const mirrorMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });

// Change CircleGeometry to PlaneGeometry and use length and height variables
const geometry1 = new THREE.PlaneGeometry(length, height);

let length1 = 25; // Adjust this value to change the length of the rectangle
let height1 = 2.5; // Adjust this value to change the height of the rectangle

const mirrorMaterial1 = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });

// Change CircleGeometry to PlaneGeometry and use length and height variables
const geometry2 = new THREE.PlaneGeometry(height1, length1);


const groundMirror = new Reflector(geometry1, {
  clipBias: 0.003,
  textureWidth: window.innerWidth * window.devicePixelRatio,
  textureHeight: window.innerHeight * window.devicePixelRatio,
  color: 0xb5b5b5,
  material: mirrorMaterial,
});
groundMirror.position.set(9.2, -1.1, 9.5); // Set the position here
groundMirror.rotateY(-Math.PI / 2);



// Second Reflector
const groundMirror2 = new Reflector(geometry1, {
  clipBias: 0.003,
  textureWidth: window.innerWidth * window.devicePixelRatio,
  textureHeight: window.innerHeight * window.devicePixelRatio,
  color: 0xb5b5b5,
  material: mirrorMaterial,
});
groundMirror2.position.set(-9.1, -1.1, 8); // Set a different position here
groundMirror2.rotateY(Math.PI /2);
const minHeight = window.innerHeight *-5;
const minWidth = window.innerWidth /-5.0
VANTA.WAVES({
  el: "#animation",
  mouseControls: true,
  touchControls: true,
  gyroControls: false,
  minHeight: minHeight,
  minWidth: minWidth,
  scale: 0.65,
  scaleMobile: 1.00,
  color: 0xc0c0c,
  shininess: 150.00,
  waveHeight: 1.50,
  waveSpeed: 2.00,
  zoom: 0.65

})
        document.addEventListener("DOMContentLoaded", function () {
        // Get references to your buttons and menus
        const settingsButton = document.getElementById("settings-button");
        const playButton = document.getElementById("play-button");
        const classButton = document.getElementById("class-button");
        const settingsMenu = document.getElementById("settings-menu");
        const playMenu = document.getElementById("play-menu");

        // Add event listeners to toggle menus with custom fade animations
        settingsButton.addEventListener("click", function () {
            toggleMenu(settingsMenu);
        });

        playButton.addEventListener("click", function () {
            toggleMenu(playMenu);
        });


        // Function to toggle fade-in and fade-out classes
        function toggleMenu(menu) {
            if (menu.classList.contains("fade-in")) {
                menu.classList.remove("fade-in");
                menu.classList.add("fade-out");
            } else {
                menu.classList.remove("fade-out");
                menu.classList.add("fade-in");
            }
        }
    });

    const jumpHeight = -0.5;
    const balls = 0;


          //Set up the controls
      const controls = new PointerLockControls(camera, document.body);

      scene.add(controls.getObject());
      controls.getObject().position.y = balls;


 // Create a stats.js monitor
 const stats = new Stats();
    stats.showPanel(0); // 0: FPS, 1: MS (millisecond), 2: MB (megabytes)
    document.getElementById("statsContainer").appendChild(stats.dom);

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyDZAxDZuJyLxxyQ9ZmYmhjj0Gvg-IuGMYU",
  authDomain: "d-test-9077c.firebaseapp.com",
  databaseURL: "https://d-test-9077c-default-rtdb.firebaseio.com",
  projectId: "d-test-9077c",
  storageBucket: "d-test-9077c.appspot.com",
  messagingSenderId: "502203730679",
  appId: "1:502203730679:web:9f4d073ca7e586a787e1f2"
};
let gameInt = false;
let playerNumber;
firebase.initializeApp(firebaseConfig);
let database = firebase.database();
const connectionsRef = database.ref("connections");
let userConnectionRef;
let userId;


const consoleStyle = `
  font-weight: bold;
  font-size: 50px;
  color: #007acc;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);`;

console.log(`%c
hello mr ellis this wraps all the code inside a constructer class I hope you are happy now`, consoleStyle);

class CodeWrapper {
  constructor() {
  
    function assignPlayerNumber() {
  connectionsRef.once("value")
    .then(snapshot => {
      const connectedPlayersCount = snapshot.numChildren();
      console.log(`Connected Players: ${connectedPlayersCount}`);

      if (connectedPlayersCount >= 2) {
        alert("Game is Full");
      } else {
        // Initialize an array to keep track of used player numbers
        const usedPlayerNumbers = [];
        snapshot.forEach(childSnapshot => {
          const playerNum = childSnapshot.val();
          usedPlayerNumbers.push(playerNum);
        });

        // Assign the first available player number (1 or 2)
        playerNumber = 1;
        if (usedPlayerNumbers.includes(1)) {
          playerNumber = 2;
        }

        if (!userConnectionRef) {
          userConnectionRef = connectionsRef.push(playerNumber);
          console.log(`You are Player ${playerNumber}`);
          userConnectionRef.onDisconnect().remove();

          if (!gameInt) {
            init();
            gameInt = true;
          }
        }
      }
    })
    .catch(error => {
      console.error("Error getting connected players count:", error);
    });
}

function handlePlayerDisconnect() {
  if (playerNumber) {
    userConnectionRef.onDisconnect().remove();
  }
}


 


this.play = () => {
      assignPlayerNumber();
      handlePlayerDisconnect();
    };






function init(){
  const hitDisplay = document.getElementById("hitDisplay");
  const killDisplay = document.getElementById("killDisplay");
  const youDiedDisplay = document.getElementById("youDiedDisplay");

console.log(playerNumber)
      // Set up the scene, camera, and renderer
       // Set up the scene, camera, and renderer
    // Create the camera
      const renderer = new THREE.WebGLRenderer({  });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.domElement.id = 'myCanvas';

document.body.appendChild(renderer.domElement);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Higher quality, softer shadows
// or
// Enable tone mapping
const toneMapping = THREE.ReinhardToneMapping; // You can use other tone mapping algorithms like ACESFilmicToneMapping
renderer.toneMapping = toneMapping;
renderer.toneMappingExposure = 2.0; // Adjust the exposure value as needed



const loadingManager = new THREE.LoadingManager();
loadingManager.onLoad = function () {
  console.log('gameLoad')
}

let mapLoad = false;
const loadingText = document.getElementById('loading-text');
let highestProgress = 0; // To track the highest progress value

loadingManager.onProgress = function (url, itemsLoaded, itemsTotal) {
    const progress = Math.round((itemsLoaded / itemsTotal) * 100);
    
    // Update the highestProgress only if the current progress is higher
    highestProgress = Math.max(progress, highestProgress);
    
    loadingText.innerHTML = `Loading...  ${highestProgress}% <i class="fa-solid fa-gear fa-spin"></i>`;

    if (mapLoad && highestProgress === 100) {
        loadingText.innerHTML = "Loading Complete";
        setTimeout(() => {
            loadingText.style.display = 'none';
            document.getElementById("gameContainer").style.display = 'block'
        }, 500);
    }
};

loadingManager.onError = function (url) {
    console.error(`Failed to load ${url}`);
    alert("Failed to load " + url);
};


// Lighting
const ambientLight = new THREE.AmbientLight(0xFFFFFF, 1.5);
    ambientLight.position.set(-64, 115, 66);
    scene.add(ambientLight);





      // Create the floor object
      const floorGeometry = new THREE.PlaneGeometry(50, 50);
      const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;

      let gun;


// Assuming you already have a scene, camera, and renderer defined
const loader1 = new FBXLoader(loadingManager);




loader1.load('https://theactualzenaldv2.github.io/gamedev/public2/extra/SciFiRifle.fbx', function (object) {
    gun = object;
    gun.scale.set(0.003, 0.003, 0.003); // Set the scale of the gun model
    gun.position.set(1.5, -1, -2); // Set the position of the gun model
    gun.rotation.x = Math.PI; // Rotate the gun model around the x axis
    gun.rotation.z = Math.PI; // Rotate the gun model around the y axis
    // Load the gun texture
    const textureLoader = new THREE.TextureLoader();
    const gunTexture = textureLoader.load('https://i.imgur.com/bqPrFZn.jpg');
    gunTexture.repeat.set(0.0032, 0.0032); // Set the repeat property of the texture

    // Create a material with a fixed color
    const gunMaterial = new THREE.MeshStandardMaterial({
        color: 0xc982e8,
        map: gunTexture,
        transparent: true,

    });

    // Apply the material to the gun mesh
    gun.material = gunMaterial;

    // Set the material of the gun model
    gun.traverse(function (node) {
        if (node.isMesh) {
            node.material = gunMaterial;
            node.material.needsUpdate = true; // Set the needsUpdate property to true to update the material
        }
    });

    // Set the render order and disable depth testing
    gun.renderOrder = 999999999;
    gun.traverse(function (node) {
        if (node.isMesh) {
            node.material.depthTest = false;
        }
    });
    camera.add(gun); // Add the gun model as a child of the camera



});


      const textureLoader = new THREE.TextureLoader(loadingManager);
    textureLoader.load('https://i.imgur.com/7EFwzds.jpg'); //overlay experimental background img 
    //
    //
    //possible skyboxes made with https://skybox.blockadelabs.com/
    //
    //
    //https://i.imgur.com/H9VQm8h.jpg
    //https://i.imgur.com/ZEtn2vn.jpg
    //https://i.imgur.com/y4K0Idj.jpg
    //https://i.imgur.com/Qp9m02L.jpg <=== best so far
    //https://i.imgur.com/7EFwzds.jpg
    const texture = textureLoader.load('https://i.imgur.com/7gsPP4X.jpg');

    // Create the skybox geometry
    const skyboxGeometry = new THREE.SphereGeometry(1000, 32, 32);

    // Create the skybox material with the loaded texture
    const skyboxMaterial = new THREE.MeshStandardMaterial({
        map: texture,
        side: THREE.BackSide
    });
    // Create the skybox mesh
    const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
    skybox.position.set(0, 100, 0);

    // Add the skybox to the scene
    scene.add(skybox);
   

    
    let dashSpeed = 13.5;
    let lastShiftTime = 0;
    let shiftAvailable = true;
    var timeSinceLastShift;

      // Set up the raycaster for collision detection
      const raycaster = new THREE.Raycaster();
      const direction = new THREE.Vector3();
      const keyboard = {};
  
    var playersRef = database.ref("players");
    var bulletsRef = database.ref("bullets")
    
      function handleKeyDown(event) {
  const key = event.key.toLowerCase();
  keyboard[key] = true;

  if (key === " ") {
            if (!isJumping) {
                isJumping = true;
                jumpVelocity = jumpSpeed;
            }
}
      }

function handleKeyUp(event) {
  const key = event.key.toLowerCase();
  keyboard[key] = false;
}
let maxSpeed = 3.5;
var speed = 3.5;
document.addEventListener("keydown", handleKeyDown);
document.addEventListener("keyup", handleKeyUp);
const dashProgressBar = document.getElementById("dash-progress-bar");

let isDashing = false;
let startTime = 0;

function startDash() {
  isDashing = true;
  startTime = performance.now();
  dashProgressBar.style.display = "block";
}

function stopDash() {
  isDashing = false;
  dashProgressBar.style.display = "none";
}
function animate() {
  stats.begin();
  requestAnimationFrame(animate);

  const currentTime = performance.now();
  timeSinceLastShift = currentTime - lastShiftTime;

  if (keyboard["shift"] && shiftAvailable && timeSinceLastShift > 5000) {
    speed = dashSpeed;

    if (!isDashing) {
      startDash();
    }

    const progress = (currentTime - startTime) / 1500;
    document.querySelector(".progress").style.width = `${Math.min(progress * 100, 100)}%`;

    if (progress >= 1) {
      stopDash();
      shiftAvailable = false;
      lastShiftTime = currentTime;

      setTimeout(() => {
        shiftAvailable = true;
      }, 1500);
    }
  } else {
    stopDash();
    speed = maxSpeed;
  }
  // Check for collisions with the floor
  raycaster.set(
    controls.getObject().position,
    new THREE.Vector3(0, 0, 0)
  );
  const intersects = raycaster.intersectObject(floor);
  if (intersects.length > 0) {
    const distance = intersects[0].distance;
    if (distance < 1) {
      controls.getObject().position.y += 1 - distance;
    }
  }

  // Render the scene
  renderer.render(scene, camera);
  stats.end();

}
let mapUrl = "https://theactualzenaldv2.github.io/Game-Development-2023/assignments/assets/Winter1v1%20(1).gltf";
let gltf;

// Load the GLTF model
const gltfLoader = new GLTFLoader(loadingManager);
gltfLoader.load(mapUrl, function (loadedGltf) {
    // Assign the loaded gltf to the global variable
    gltf = loadedGltf;
    gltf.scene.scale.set(0.13, 0.13, 0.13);
    gltf.scene.position.set(0, -7, 0);
    gltf.frustumCulled = true;
    mapLoad = true;

    // Traverse through the model and enable shadow casting for each object
    gltf.scene.traverse(function (object) {
        if (object.isMesh) {
            object.castShadow = true;
            object.receiveShadow = true;

        }
    });

    // Add the model to the scene
    scene.add(gltf.scene);
    animate();
    chooseInitialSpawn();
}, // Called if there is an error loading the model
function (error) {
    console.error(error);
});

const floorHeight = -0; // Set the floor height threshold for collisions


setInterval(() => {
  updateBullets();
  updateOtherPlayerBullets();
  }, 10);

  let jumpVelocity = 0;
  let jumpVelocity1 = 0.45;
let isJumping = false;
let lastTime = 0;
const jumpSpeed = 0.15;
      // Store the initial position
  var initialPosition = controls.getObject().position.clone();

  const impulse = new THREE.Vector3(0, 0, -0.1); // Adjust the values as needed

  
function findPositionOutsideCollision(initialPosition, impulse) {
    const maxAttempts = 10;
    let attempt = 0;
    let newPosition = initialPosition.clone();

    while (attempt < maxAttempts && detectCollisionsAtPosition(newPosition)) {
        // Move the position away from the colliding object
        newPosition.addScaledVector(impulse, 0.1); // Adjust the scaling factor as needed
        attempt++;
    }

    return newPosition;
}

function detectCollisionsAtPosition(position) {
    // Check if the gltf variable is defined
    if (gltf) {
        // Loop through the children of the GLTF model to check for collisions
        for (let child of gltf.scene.children) {
            // Check if the child object is below the floor height threshold
            if (child.position.y < floorHeight) {
                continue; // Skip this object
            }

            // Check if the material is collidable
            if (child.material && child.material.collidable === false) {
                continue; // Skip this object
            }

            // Create a new bounding box for the child object
            const box = new THREE.Box3().setFromObject(child);
            // Add padding to the box
            box.expandByScalar(0.2);

            // Check collision with player at the new position
            if (box.containsPoint(position)) {
                console.log("Collision detected at new position");
                return true;
            }
        }
    } else {
        console.log('GLTF model not loaded yet');
    }

    return false;
}


function movePlayer() {
  const time = performance.now(); // Use performance.now() for high-precision timing

  if (!lastTime) {
    lastTime = time;
    return;
  }
  const deltaTime = (time - lastTime) / 1000; // Convert to seconds


  const gravity = 5.81; // Adjust the gravity strength
  const jumpCooldown = 350; // Adjust this for the jump cooldown duration in milliseconds

  const forward = new THREE.Vector3(
    controls.getObject().matrix.elements[8],
    0,
    controls.getObject().matrix.elements[10]
  );
  const backward = forward.clone().negate();
  const left = new THREE.Vector3(
    controls.getObject().matrix.elements[0],
    0,
    controls.getObject().matrix.elements[2]
  );
  const right = left.clone().negate();
  const velocity = new THREE.Vector3();

  // Move the user
  if (keyboard["w"]) {
    velocity.add(backward);
  }
  if (keyboard["s"]) {
    velocity.add(forward);
  }
  if (keyboard["a"]) {
    velocity.add(right);
  }
  if (keyboard["d"]) {
    velocity.add(left);
  }
  velocity.normalize();
  velocity.multiplyScalar(speed * deltaTime);

  initialPosition = controls.getObject().position.clone();
  // Apply velocity to the position
  controls.getObject().position.add(velocity);

 // Check for collisions again at the new position
 if (detectCollisions()) {
        // If there is still a collision, find a new position outside the colliding object
        const newPosition = findPositionOutsideCollision(initialPosition, impulse);
        controls.getObject().position.copy(newPosition);
    }

const objectBelowHeight = getObjectBelowHeight(controls.getObject().position);
// Jumping logic
if(objectBelowHeight <=5 && objectBelowHeight != 0.8300000000000004){


if (isJumping) {
    jumpVelocity -= jumpVelocity1 * deltaTime;
    const newPositionY = controls.getObject().position.y + jumpVelocity / 2;

    // Check if the new position is above the object below
    if (newPositionY < objectBelowHeight) {

        // Smoothly move to the new position
        controls.getObject().position.y = lerp(controls.getObject().position.y, objectBelowHeight, 0.09);
        if (Math.abs(controls.getObject().position.y - objectBelowHeight) < 0.01) {
            isJumping = false;
            jumpVelocity = 0;
        }
    } else {
        // Smoothly move to the new position
        controls.getObject().position.y = lerp(controls.getObject().position.y, newPositionY, 0.5);
    }
} else {
    jumpVelocity -= jumpVelocity1 * deltaTime;
    const newPositionY = controls.getObject().position.y + jumpVelocity / 2;
    if (newPositionY > objectBelowHeight) {
        // Smoothly move to the new position
        controls.getObject().position.y = lerp(controls.getObject().position.y, objectBelowHeight, 0.09);
        if (Math.abs(controls.getObject().position.y - objectBelowHeight) < 0.01) {
            jumpVelocity = 0;
        }
    }
}
} else {
    // Smoothly move to the new position
    controls.getObject().position.y = lerp(controls.getObject().position.y, floorHeight, 0.09);
        if (Math.abs(controls.getObject().position.y - floorHeight) < 0.01) {
            jumpVelocity = 0;
        }
}

  




        // Round the position values to 2 decimal places
  controls.getObject().position.x = parseFloat(controls.getObject().position.x.toFixed(6));
  controls.getObject().position.y = parseFloat(controls.getObject().position.y.toFixed(6));
  controls.getObject().position.z = parseFloat(controls.getObject().position.z.toFixed(6));

  if (!userId) return;

  // Update the player's position in the database (This happens every 30ms)
  const x = controls.getObject().position.x;
  const y = controls.getObject().position.y;
  const z = controls.getObject().position.z;
  const playerRef = playersRef.child(userId);
  playerRef.update({ x, y, z, health });

  lastTime = time;
}

// Define a function for linear interpolation (lerp)
function lerp(start, end, alpha) {
    return start + alpha * (end - start);
}

setInterval(() => {
  movePlayer()
}, 1000/165);
function calculateCollisionNormal() {
  let normal = new THREE.Vector3();

  // Loop through all colliding objects
  for (let child of gltf.scene.children) {
    // Skip if the child object is below the floor height threshold or not collidable
    if (child.position.y < floorHeight || (child.material && child.material.collidable === false)) {
      continue;
    }

    // Create a new bounding box for the child object
    const box = new THREE.Box3().setFromObject(child);

    // Check collision with player
    if (box.containsPoint(controls.getObject().position)) {
      // Calculate the normal by subtracting the player's position from the object's position
      let objectNormal = controls.getObject().position.clone().sub(child.position);

      // Ignore vertical component of the normal
      objectNormal.y = 0;

      // Normalize and add this normal to the total normal
      normal.add(objectNormal.normalize());
    }
  }

  // Normalize the total normal to get an average direction
  normal.normalize();

  return normal;
}






// Function to get the height of the object below the specified position
function getObjectBelowHeight(position) {
    let objectBelowHeight = floorHeight; // Default to the floor height

    // Check if the gltf variable is defined
    if (gltf) {
        // Loop through the children of the GLTF model to find the object below
        for (let child of gltf.scene.children) {
            // Check if the child object is below the floor height threshold
            if (child.position.y < floorHeight) {
                continue; // Skip this object
            }

            // Check if the material is collidable
            if (child.material && child.material.collidable === false) {
                continue; // Skip this object
            }

            // Create a new bounding box for the child object
            const box = new THREE.Box3().setFromObject(child);
            // Add padding to the box
            box.expandByScalar(0.4);

            // Check if the player's position is above the object
            if (box.containsPoint(position)) {
                objectBelowHeight = box.max.y; // Use the top of the object as the new height
                break; // Stop checking further objects
            }
        }
    }

    return objectBelowHeight;
}


function addPlayer(){
  // Generate a unique ID for the new player
  var newPlayerRef = playersRef.push();
  userId = newPlayerRef.key;
  controls.getObject().position.y = balls;
  const x = controls.getObject().position.x;
  const y = controls.getObject().position.y;
  const z = controls.getObject().position.z;



  // Add the new player to the database
  newPlayerRef.set({
  x,
  y,
  z,
  });

  const playerRef = firebase.database().ref(`players/${userId}`);
  playerRef.onDisconnect().remove();
  bulletsRef.remove();
  pingDatabase(userId);

}
addPlayer();


 // Function to ping the database and update ping response time
 function pingDatabase(userId) {
  const pingTimeElement = document.getElementById('pingTime');

  if (userId) {
                            setInterval(() => {
                                // Send a ping under the current user's username to the Firebase database to measure response time
                                const pingStart = performance.now();
                                firebase.database()
                                    .ref(`players/${userId}/ping`)
                                    .set(Date.now())
                                    .then(function () {
                                        // Read the ping value from the Firebase database and calculate the response time
                                        firebase.database()
                                            .ref(`players/${userId}/ping`)
                                            .once("value")
                                            .then(function (snapshot) {
                                                const pingEnd = performance.now();
                                                const pingTime = pingEnd - pingStart;
                                                const pingValue = snapshot.val();
                                                const pingResponseTime = Date.now() - pingValue;
                                                pingTimeElement.innerHTML = pingResponseTime;

                                            });
                                    });
                            }, 500);


                        }
    }


let health = 100;
let deaths = 0;
let ammo = 30;
const maxAmmo = 30;
// Create a group for other players
const otherPlayersGroup = new THREE.Group();
      scene.add(otherPlayersGroup);
 // Function to draw other players from the database
 
 function drawOtherPlayers(playerData) {
  // Clear the existing other players
  otherPlayersGroup.children.length = 0;

  // Iterate through playerData to draw each player
  for (const playerId in playerData) {
    if (playerId !== userId) {
      const playerPosition = playerData[playerId];

      // Create the player's body
      const bodyGeometry = new THREE.SphereGeometry(0.5, 32, 32); // Adjust the radius and segments as needed
      const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(playerPosition.x, playerPosition.y, playerPosition.z);

      // Create the player's head
      const headGeometry = new THREE.SphereGeometry(0.3, 32, 32); // Adjust the radius and segments as needed
      const headMaterial = new THREE.MeshBasicMaterial({ color: 0x8b0000 }); // Dark red color
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.set(playerPosition.x, playerPosition.y + 0.5, playerPosition.z); // Adjust the Y position

      // Create a group to hold both body and head
      const playerGroup = new THREE.Group();
      playerGroup.add(body);
      playerGroup.add(head);

      otherPlayersGroup.add(playerGroup);
    }
  }
}

let playersInfo = [];
let kills = 0;
let killReward = false;
let gameEnded = false;
const youKilledDisplay = document.getElementById("youKilledDisplay");
const youHitDisplay = document.getElementById("youHitDisplay");
const playerRef = playersRef.child(userId);

// Store the previous health values for each player
const previousHealthValues = {};


// Listen for changes in other players' positions
playersRef.on("value", (snapshot) => {
  const playerData = snapshot.val();

// Check if playerData is not null or undefined
if (playerData && !gameEnded) {
  const leaderboardBody = document.getElementById('leaderboardBody');
  leaderboardBody.innerHTML = ''; // Clear existing data

  gameEnded = false;

  // Iterate through all players
  Object.keys(playerData).forEach((playerId) => {
    const player = playerData[playerId];

    // Create a new row for each player
    const kdRatio = player.deaths === 0 ? player.kills : (player.kills / player.deaths).toFixed(2);

    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${playerId}</td>
      <td>${player.kills}</td>
      <td>${player.deaths}</td>
      <td>${kdRatio}</td>
    `;

    // Append the row to the leaderboard
    leaderboardBody.appendChild(row);

    // Check if the player has 1 kill
    if (player.kills === 5) {
      gameEnded = true;
    }
  });

  // Check if the game has ended for any player
  if (gameEnded) {
    document.getElementById("gameOverContainer").style.display = 'block';
    document.getElementById("gameContainer").style.display = 'none';
    document.getElementById("myCanvas").style.display = 'none';
  }
}
  // Filter out the players with the same playerId
  playersInfo = Object.keys(playerData)
    .filter((key) => key !== userId)
    .map((key) => playerData[key]);

  // Log the health value of each player and check for hits
  playersInfo.forEach((player) => {
    if(player.health === undefined) return;
    document.getElementById("enemyHealthNumber").innerHTML = player.health;
    console.log(`Enemy has ${player.health} health.`);

    // Check if the player has a previous health value
    if (previousHealthValues[player.playerId] !== undefined) {
      // Calculate the difference between current and previous health
      const healthDifference = previousHealthValues[player.playerId] - player.health;

      if (healthDifference >= 30) {
        console.log('Crit hit!'); // Log crit hit
        youHitDisplay.textContent = 'Crit Hit!'; // Update display for crit hit
        document.getElementById("enemyHealthNumber").innerHTML = player.health;
      } else if (healthDifference == 5){
        youHitDisplay.textContent = 'Leg Shot!'; // Update display for regular hit
        document.getElementById("enemyHealthNumber").innerHTML = player.health;

      } else if (healthDifference > 0 && player.health !== 100) {
        console.log('Regular hit!'); // Log regular hit
        youHitDisplay.textContent = 'Hit!'; // Update display for regular hit
        document.getElementById("enemyHealthNumber").innerHTML = player.health;
      }

      // Show the hit display only if there has been a change in health
      if (healthDifference !== 0) {
        youHitDisplay.style.display = 'block';

        // Hide the hit display after a delay
        setTimeout(() => {
          youHitDisplay.style.display = 'none';
        }, 2000);
      }
    }

    // Check if the player's health has reached 0
    if (player.health <= 0) {
      console.log('You killed an enemy');
      setTimeout(() => {
        if(!killReward){
        console.log(killReward)
        killReward = true;
        kills++
         
        document.getElementById('killsCount').innerHTML = kills;
        setTimeout(() => {
            killReward = false;
        }, 1500);

      }  
      },100);
      
      resetPosition();
      youKilledDisplay.style.display = 'block';
      bulletsRef.remove();
      setTimeout(() => {
        youKilledDisplay.style.display = 'none';
      }, 2000);
    }

    // Update the previous health value for this player
    previousHealthValues[player.playerId] = player.health;
  });

  drawOtherPlayers(playersInfo);
});
//update k/d
setInterval(() => {
  playerRef.update({
            kills: kills,
            deaths: deaths,
          })
}, 10);




const bullets = []
function detectBulletCollisions() {
        // Check if the gltf variable is defined
        if (gltf) {
            // Loop through the children of the GLTF model to check for collisions
            for (let child of gltf.scene.children) {
                // Compute the bounding box for the child object
                const box = new THREE.Box3()
                    .setFromObject(child);

                for (let bullet of bullets) {
                    // Origin point of bullet
                    const originPoint = bullet.position.clone();
                    if (box.containsPoint(originPoint)) {
                        // Remove the bullet from the scene
                        scene.remove(bullet);
                        // Set the collision flag to true
                        return true;
                    }
                }
            }
        }
        else {
            console.log('GLTF model not loaded yet');
        }
        // No collision detected, return false
        return false;
    }

function detectCollisions() {
        let collisionDetected = false;
        // Check if the gltf variable is defined
        if (gltf) {
            // Loop through the children of the GLTF model to check for collisions
            for (let child of gltf.scene.children) {
                // Check if the child object is below the floor height threshold
                if (child.position.y < floorHeight) {
                    continue; // Skip this object
                }

                // Check if the material is collidable
                if (child.material && child.material.collidable === false) {
                    continue; // Skip this object
                }

                // Create a new bounding box for the child object
                const box = new THREE.Box3()
                    .setFromObject(child);
                // Add padding to the box
                box.expandByScalar(0.2);

                // Check collision with player
                if (box.containsPoint(camera.position)) {
                    console.log("Collision detected");
                    collisionDetected = true;
                }
            }
        }
        else {
            console.log('GLTF model not loaded yet');
        }

        return collisionDetected;
    }
const globalBulletSpeed = 0.8;
// Function to handle shooting
const bulletSpeed = globalBulletSpeed; // Adjust bullet speed
// Function to handle shooting


function startRecoil() {
        if (isReloading) return;
        
        // Set the recoil animation
        let start = null;
        const duration = 100; // Duration of the animation in milliseconds
        const distance = 0.55; // Distance to move the gun in the z-axis
        const animate = (timestamp) => {
            if (!start) start = timestamp;
            const elapsed = timestamp - start;
            const progress = Math.min(elapsed / duration, 1);
            gun.position.z = -distance * Math.sin(progress * Math.PI) - 2;
            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        };
        requestAnimationFrame(animate);
    }


function shoot() {
  startRecoil(); // Start the recoil animation

  const bulletGeometry = new THREE.SphereGeometry(0.05, 16, 16); // Adjust the radius and segments as needed
const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Change color to differentiate
const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

  // Set the bullet's position based on the player's position and direction
  const playerPosition = controls.getObject().position.clone();
  const direction = new THREE.Vector3();
  controls.getDirection(direction);
  const bulletLifetime = 3000; // Adjust bullet lifetime in milliseconds
  const bulletSpeed = globalBulletSpeed; // Adjust bullet speed

  bullet.position.copy(playerPosition);
  bullet.userData.direction = direction.clone().multiplyScalar(bulletSpeed);
  bullet.userData.startTime = Date.now();
  bullet.userData.speed = bulletSpeed; // Store bullet speed
  bullet.userData.owner = userId;


  // Add the bullet to the scene and bullets array
  scene.add(bullet);

  // Send bullet origin, direction, speed, and timestamp to Firebase
  const bulletData = {
    origin: {
      x: playerPosition.x,
      y: playerPosition.y,
      z: playerPosition.z,
    },
    direction: {
      x: direction.x,
      y: direction.y,
      z: direction.z,
    },
    speed: bulletSpeed, // Include bullet speed
    timestamp: Date.now(),
    id: userId,
    owner: userId,
  };

  // Push bullet data to Firebase and get the key assigned by Firebase
  const newBulletRef = bulletsRef.push(bulletData);
  const bulletKey = newBulletRef.key;

  // Store the bullet key in the bullet's userData
  bullet.userData.key = bulletKey;

  // Push the bullet to your bullets array
  bullets.push(bullet);
}

const otherPlayerBullets = []
// Event listener for mouse button down (hold to shoot)
// Define a variable to track the time of the last shot
// Define a variable to track the time of the last shot
let lastShotTime = 0;
let isReloading = false;


// Define the minimum delay between shots (in milliseconds)
const shotDelay = 75; // Adjust this value to set your desired delay
document.getElementById("ammoCount").innerHTML = ammo;

let shootingInterval; // Variable to store the interval ID

// Function to handle shooting
function handleShoot() {
  if (ammo === 0){
setTimeout(() => {
  reloadWeapon();
}, 300);
return;

  } 
  if(isReloading) return;
  
  const currentTime = Date.now();

  // Calculate the time elapsed since the last shot
  const timeSinceLastShot = currentTime - lastShotTime;

  // Check if enough time has elapsed since the last shot
  if (timeSinceLastShot >= shotDelay) {
    // Call the shoot function when the conditions for shooting are met
    shoot();
    ammo--;
    document.getElementById("ammoCount").innerHTML = ammo;

    // Update the last shot time
    lastShotTime = currentTime;
  }
}

// Event listener for mouse button down (hold to shoot)
document.addEventListener("mousedown", () => {
  // Start shooting at the specified interval
  shootingInterval = setInterval(handleShoot, shotDelay);

  // Initial shot
  handleShoot();
});

// Event listener for mouse button release (stop shooting)
document.addEventListener("mouseup", () => {
  // Clear the shooting interval when the mouse button is released
  clearInterval(shootingInterval);
});


// Add an event listener to the document for the "keydown" event
document.addEventListener("keydown", function (event) {
  //reload key
  if (event.keyCode === 82)  {
reloadWeapon();

  }
});

function instantReload(){
  ammo = maxAmmo;
  document.getElementById('ammoCount').innerHTML = ammo;

}
function reloadWeapon() {
  if (ammo === maxAmmo) return;
  if (isReloading) return;
  isReloading = true;
  document.getElementById("ammoCount").innerHTML = 'Reloading';

  // Reload animation
  const reloadInterval = setInterval(() => {
    if (gun.position.z < 2.5) {
      gun.position.z += 0.1;
    }
  }, 10);

  setTimeout(() => {
    clearInterval(reloadInterval);

  // Move the gun back to its original position
  const moveBackInterval = setInterval(() => {
                if (gun.position.z > -2) {
                    gun.position.z -= 0.1;
                }
                else {
                    // Set reloading flag to false when the gun is back in its original position
                    isReloading = false;
                    clearInterval(moveBackInterval);
                    ammo = maxAmmo;
                    document.getElementById('ammoCount').innerHTML = ammo;

                   
                }
            }, 10);
    }, 1500);

    // Check if the gun is reloading every 100ms and stop the moveBackInterval if it's not
    const checkReloadingInterval = setInterval(() => {
      if (!isReloading) {
        clearInterval(checkReloadingInterval);
      }
    }, 100);
}

// Function to check collision between two objects (player and bullet)
function checkCollision(playerPosition, bullet, key) {
  if(key === userId) return;
  const playerBoundingBox = new THREE.Box3().setFromCenterAndSize(playerPosition, new THREE.Vector3(1, 2, 1)); // Adjust size as needed
  const bulletBoundingBox = new THREE.Box3().setFromObject(bullet);
  return playerBoundingBox.intersectsBox(bulletBoundingBox);
}


const headHeightThreshold = 0.45; // Adjust this value based on your player model
const legHeightThreshold = -0.35;


// Update other players' bullets' positions and remove expired bullets
function updateOtherPlayerBullets() {
  const currentTime = Date.now();
  const bulletLifetime = 3000; // Adjust bullet lifetime in milliseconds
  // Get the player's position (camera position)
  const playerPosition = controls.getObject().position;
  for (let i = otherPlayerBullets.length - 1; i >= 0; i--) {
    const bullet = otherPlayerBullets[i];

    // Set the bullet's speed based on the stored speed in userData
    const bulletSpeed = bullet.userData.speed;

    // Update bullet position
    bullet.position.add(bullet.userData.direction.clone().multiplyScalar(bulletSpeed));

    // Remove bullets that have exceeded their lifetime
    if (currentTime - bullet.userData.startTime > bulletLifetime) {
      otherPlayerBullets.splice(i, 1);
      scene.remove(bullet);
    }

// Define variables to store the timeout IDs
let hitDisplayTimeoutId = null;
let youDiedDisplayTimeoutId = null;

// Check collision with the player
if (checkCollision(playerPosition, bullet, bullet.userData.owner)) {
  if (bullet.position.y > headHeightThreshold) {
    console.log("Critical hit");
    health -= 30;
    if (bullet.userData.owner !== userId) {
      hitDisplay.style.display = 'block';
      hitDisplay.innerHTML = 'You got CRITICALLY hit!';

      // Clear the previous hitDisplay timeout (if it exists)
      if (hitDisplayTimeoutId) {
        clearTimeout(hitDisplayTimeoutId);
      }

      // Set a new hitDisplay timeout and store its ID
      hitDisplayTimeoutId = setTimeout(() => {
        hitDisplay.style.display = 'none';
        hitDisplay.innerHTML = 'You got hit!';
        hitDisplayTimeoutId = null; // Reset the ID
      }, 2000);
    }
  } else if (bullet.position.y < legHeightThreshold) {
    console.log("Leg Hit");
    health -= 5;
    if (bullet.userData.owner !== userId) {
      hitDisplay.style.display = 'block';

      // Clear the previous hitDisplay timeout (if it exists)
      if (hitDisplayTimeoutId) {
        clearTimeout(hitDisplayTimeoutId);
      }

      // Set a new hitDisplay timeout and store its ID
      hitDisplayTimeoutId = setTimeout(() => {
        hitDisplay.style.display = 'none';
        hitDisplay.innerHTML = 'You got hit!';
        hitDisplayTimeoutId = null; // Reset the ID
      }, 2000);
    }
  } else {
    // Regular hit (not critical)
    console.log("Collision with player");
    health -= 15;
    if (bullet.userData.owner !== userId) {
      hitDisplay.style.display = 'block';

      // Clear the previous hitDisplay timeout (if it exists)
      if (hitDisplayTimeoutId) {
        clearTimeout(hitDisplayTimeoutId);
      }

      // Set a new hitDisplay timeout and store its ID
      hitDisplayTimeoutId = setTimeout(() => {
        hitDisplay.style.display = 'none';
        hitDisplayTimeoutId = null; // Reset the ID
      }, 2000);
    }
  }
  
  document.getElementById('healthNumber').innerHTML = health;
  if (health <= 0) {
    chooseSpawn();
    deaths++;
    document.getElementById('deathCount').innerHTML = deaths;
    console.log("Died");
    youDiedDisplay.style.display = "block";

    // Clear the previous youDiedDisplay timeout (if it exists)
    if (youDiedDisplayTimeoutId) {
      clearTimeout(youDiedDisplayTimeoutId);
    }

    // Set a new youDiedDisplay timeout and store its ID
    youDiedDisplayTimeoutId = setTimeout(() => {
      youDiedDisplay.style.display = 'none';
      youDiedDisplayTimeoutId = null; // Reset the ID
    }, 2000);
  }
  
  // Remove the bullet
  otherPlayerBullets.splice(i, 1);
  scene.remove(bullet);
}


  }
}

function updateHealth(){
  document.getElementById("healthNumber").innerHTML = health;
}


function resetAllKeysToFalse() {
  for (const key in keyboard) {
    if (keyboard.hasOwnProperty(key)) {
      keyboard[key] = false;
    }
  }
}

function chooseInitialSpawn(){




// To remove event listeners, you can use the same function references:
// Assuming you want to remove the listeners later, you would do something like this:


//{x: 8.22, y: -0.5, z: 0.88}   SPAWN 1
//{x: -7.8, y: -0.5, z: 17}     SPAWN 2
if(playerNumber === 1){
  controls.getObject().position.x =  8.22;
        controls.getObject().position.y =  -0
        controls.getObject().position.z =  0.88;


} else if (playerNumber === 2){
  controls.getObject().position.x = -7.8;
        controls.getObject().position.y = -0
        controls.getObject().position.z = 17;

}
       
}

function resetPosition(){
  if(kills === 10){
    console.log("gameOver")
  } else {
    console.log(kills)
  }
  health = 100; // Reset health to 100

  document.removeEventListener("keydown", handleKeyDown);
document.removeEventListener("keyup", handleKeyUp);
resetAllKeysToFalse();
document.getElementById("gameOverlay").style.opacity = "1";
setTimeout(() => {
   // Add event listeners
document.addEventListener("keydown", handleKeyDown);
document.addEventListener("keyup", handleKeyUp);
document.getElementById("gameOverlay").style.opacity = "0";


//{x: 8.22, y: -0.5, z: 0.88}   SPAWN 1
//{x: -7.8, y: -0.5, z: 17}     SPAWN 2
if(playerNumber === 1){
  controls.getObject().position.x =  8.22;
        controls.getObject().position.y =  -0
        controls.getObject().position.z =  0.88;
         health = 100; // Reset health to 100
        document.getElementById('healthNumber').innerHTML = health;
        instantReload();

} else if (playerNumber === 2){
  controls.getObject().position.x = -7.8;
        controls.getObject().position.y = -0
        controls.getObject().position.z = 17;
          health = 100; // Reset health to 100
          instantReload();

          document.getElementById('healthNumber').innerHTML = health;
}


}, 1500);
}


function chooseSpawn(){
  document.getElementById("gameOverlay").style.opacity = "1";
  document.removeEventListener("keydown", handleKeyDown);
  resetAllKeysToFalse();

document.removeEventListener("keyup", handleKeyUp);
health = 0; // Reset health to 100
document.getElementById('healthNumber').innerHTML = health;

controls.getObject().position.x =  100;
        controls.getObject().position.y =  -0
        controls.getObject().position.z =  0.88;

  setTimeout(() => {
    // Add event listeners
document.addEventListener("keydown", handleKeyDown);
document.addEventListener("keyup", handleKeyUp);
document.getElementById("gameOverlay").style.opacity = "0";


// To remove event listeners, you can use the same function references:
// Assuming you want to remove the listeners later, you would do something like this:


//{x: 8.22, y: -0.5, z: 0.88}   SPAWN 1
//{x: -7.8, y: -0.5, z: 17}     SPAWN 2
if(playerNumber === 1){
  controls.getObject().position.x =  8.22;
        controls.getObject().position.y =  -0
        controls.getObject().position.z =  0.88;
         health = 100; // Reset health to 100
        document.getElementById('healthNumber').innerHTML = health;
        instantReload();

} else if (playerNumber === 2){
  controls.getObject().position.x = -7.8;
        controls.getObject().position.y = -0
        controls.getObject().position.z = 17;
          health = 100; // Reset health to 100
       
          document.getElementById('healthNumber').innerHTML = health;
          instantReload();
}
  }, 1500);
       
}
// Add a listener to handle bullet removal when a child is removed from the database
bulletsRef.on("child_removed", function(snapshot) {
  handleBulletRemoval(snapshot);
});

// Function to handle bullet removal
function handleBulletRemoval(snapshot) {
  const bulletId = snapshot.key;
  console.log("removed bullet: " + bulletId);

  // Find the bullet in the local bullets array based on its key
  const index = bullets.findIndex(bullet => bullet.userData.key === bulletId);

  if (index !== -1) {
    // Remove the bullet from the local bullets array and scene
    const removedBullet = bullets.splice(index, 1)[0];
    scene.remove(removedBullet);
  }

  // Find the bullet in the otherPlayerBullets array based on its key
  const otherPlayerBulletIndex = otherPlayerBullets.findIndex(bullet => bullet.userData.key === bulletId);

  if (otherPlayerBulletIndex !== -1) {
    // Remove the bullet from the otherPlayerBullets array and scene
    const removedOtherPlayerBullet = otherPlayerBullets.splice(otherPlayerBulletIndex, 1)[0];
    scene.remove(removedOtherPlayerBullet);
  }
}



// Listen for child_added events for bullets from other players
bulletsRef.on("child_added", (snapshot) => {
  const bulletData = snapshot.val();
  const bulletGeometry = new THREE.SphereGeometry(0.05, 16, 16);
  const bulletMaterial = bulletData.owner !== userId
    ? new THREE.MeshBasicMaterial({ color: 0xff0000 }) // Red
    : new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Green
  const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

  // Set the bullet's position based on the received data
  bullet.position.set(bulletData.origin.x, bulletData.origin.y, bulletData.origin.z);
  bullet.userData.direction = new THREE.Vector3(bulletData.direction.x, bulletData.direction.y, bulletData.direction.z);
  bullet.userData.startTime = Date.now();
  bullet.userData.speed = bulletData.speed; // Store bullet speed
  bullet.userData.key = snapshot.key;
  bullet.userData.owner = bulletData.owner;

  // Add the bullet to the scene and otherPlayerBullets array
  scene.add(bullet);
  otherPlayerBullets.push(bullet);
});




// Update bullets' positions and remove expired bullets
function updateBullets() {
  const currentTime = Date.now();
  const bulletLifetime = 3000; // Adjust bullet lifetime in milliseconds

  for (let i = bullets.length - 1; i >= 0; i--) {
    const bullet = bullets[i];

    // Update bullet position
    bullet.position.add(bullet.userData.direction);

    // Remove bullets that have exceeded their lifetime
    if (currentTime - bullet.userData.startTime > bulletLifetime) {
      // Check if the bullet still exists in the bullets array
      if (bullets.includes(bullet)) {
        bullets.splice(i, 1);
        scene.remove(bullet);
      }
    }

    if (detectBulletCollisions()) {
      console.log("hit wall");
      bulletsRef.child(bullet.userData.key).remove();
      
      // Check if the bullet still exists in the bullets array
      if (bullets.includes(bullet)) {
        bullets.splice(i, 1);
        scene.remove(bullet);
      }
    }
  }
}





 


    //on window resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
  }

  }

}

// Create an instance of the class
const myInstance = new CodeWrapper();
// You can now call the play() method from a button click or any other external code
document.getElementById("play-button").addEventListener("click", () => {
  myInstance.play();
  
  document.addEventListener("click", () => {
        controls.lock();
      });
  document.getElementById("menu").style.display = 'none';
  document.getElementById("animation").style.display = 'none'
  document.getElementById("loading-text").style.display = 'block'
});

  </script>
  
  
  
  </script>
    <script>


    </script>
  </body>
</html>
